// F. Отрезки времени (20 баллов)
// ограничение по времени на тест2 секунды
// ограничение по памяти на тест512 мегабайт
// вводстандартный ввод
// выводстандартный вывод
// Вам задан набор отрезков времени. Каждый отрезок задан в формате HH:MM:SS-HH:MM:SS, то есть сначала заданы часы, минуты и секунды левой границы отрезка, а затем часы, минуты и секунды правой границы.
//
// Вам необходимо выполнить валидацию заданного набора отрезков времени. Иными словами, вам нужно проверить следующие условия:
//
// часы, минуты и секунды заданы корректно (то есть часы находятся в промежутке от 0
//  до 23
// , а минуты и секунды — в промежутке от 0
//  до 59
// );
// левая граница отрезка находится не позже его правой границы (но границы могут быть равны);
// никакая пара отрезков не пересекается (даже в граничных моментах времени).
// Вам необходимо вывести YES, если заданный набор отрезков времени проходит валидацию, и NO в противном случае.
//
// Вам необходимо ответить на t
//  независимых наборов тестовых данных.
//
// Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
//
// Входные данные
// Первая строка входных данных содержит одно целое число t
//  (1≤t≤10
// ) — количество наборов тестовых данных. Затем следуют t
//  наборов.
//
// Первая строка набора содержит одно целое число n
//  (1≤n≤2⋅104
// ) — количество отрезков времени. В следующих n
//  строках следуют описания отрезков.
//
// Описание отрезка времени задано в формате HH:MM:SS-HH:MM:SS, где HH, MM и SS — последовательности из двух цифр. Заметьте, что никаких пробелов в описании формата нет. Также ни в одном описании нет пробелов в начале и конце строки.
//
// Выходные данные
// Для каждого набора тестовых данных выведите ответ — YES, если заданный набор отрезков времени проходит валидацию, и NO в противном случае. Ответы выводите в порядке следования наборов во входных данных.
//
// Пример
// входные данныеСкопировать
// 6
// 1
// 02:46:00-03:14:59
// 2
// 23:59:59-23:59:59
// 00:00:00-23:59:58
// 2
// 23:59:58-23:59:59
// 00:00:00-23:59:58
// 2
// 23:59:59-23:59:58
// 00:00:00-23:59:57
// 6
// 17:53:39-20:20:02
// 10:39:17-11:00:52
// 08:42:47-09:02:14
// 09:44:26-10:21:41
// 00:46:17-02:07:19
// 22:42:50-23:17:46
// 1
// 24:00:00-23:59:59
// выходные данныеСкопировать
// YES
// YES
// NO
// NO
// YES
// NO

// class Result
// {
// 	public static string Execute(List<(string, string)> source)
// 	{
// 		List<(DateTime, DateTime)> data;
// 		try
// 		{
// 			data = source
// 				.Select(p => (DateTime.Parse(p.Item1), DateTime.Parse(p.Item2))
// 				).ToList();
// 		}
// 		catch
// 		{
// 			return "NO";
// 		}
// 		
// 		
// 		if (data.Any(p => p.Item1 > p.Item2))
// 			return "NO";
// 		
// 		List<(DateTime, DateTime)> sorted = data.OrderBy(p => p.Item1).ToList();
//
// 		bool isValid = true;
// 		DateTime end = DateTime.MinValue;
// 		for (int i = 0; i < sorted.Count; i++)
// 		{
// 			if (i == 0)
// 			{
// 				end = sorted[i].Item2;
// 				continue;
// 			}
//
// 			if (sorted[i].Item1 <= end)
// 			{
// 				isValid = false;
// 				break;
// 			}
// 			
// 			end = sorted[i].Item2;
// 		}
//
// 		string result = isValid ? "YES" : "NO";
// 		
// 		return result;
// 	}
// }
//
// class Solution
// {
// 	public static void Main(string[] args)
// 	{
// 		int inputCount = Convert.ToInt32(Console.ReadLine().Trim());
// 		var results = new List<string>();
// 			
// 			
// 		for (int i = 0; i < inputCount; i++)
// 		{
// 			int count = Convert.ToInt32(Console.ReadLine().Trim());
//
// 			var datas = new List<(string, string)>();
// 			for (int j = 0; j < count; j++)
// 			{
// 				var data = Console.ReadLine().TrimEnd().Split("-");
// 				datas.Add(new(data[0], data[1]));
// 			}
// 		
// 			string result = Result.Execute(datas);
// 			results.Add(result);
// 		}
//
// 		foreach (var result in results)
// 		{
// 			Console.WriteLine(result);
// 		}
// 	}
// }